Introduction
------------

This document describes extensions (and some minor changes) to the
existing ARM ELF ABI (as used on GNU/Linux) required to support the
implementation of shared libraries on a system whose OS (and hardware)
require that processes share a common address space.  This document
will also attempt to explore the motivations behind and the
implications of these extensions.

One of the primary goals in using shared libraries is to reduce the
memory requirements of the overall system.  Thus, if two processes use
the same library, the hope is that at least some of the memory pages
will be shared between the two processes resulting in an overall
savings.  To realize these savings, tools used to build a program and
library must identify which sections may be shared and which must not
be shared.  The shared sections, when grouped together, are commonly
referred to as the "text segment" whereas the non-shared (grouped)
sections are commonly referred to as the "data segment".  The text
segment is read-only and is usually comprised of executable code and
read-only data.  The data segment must be writable and it is this fact
which makes it non-sharable.

Systems which utilize disjoint address spaces for its processes are
free to group the text and data segments in such a way that they
may always be loaded with fixed relative positions of the text
and data segments.  I.e, for a given load object, the offset from
the start of the text segment to the start of the data segment is
constant.  This property greatly simplifies the design of the
shared library machinery.

The design of the shared library mechanism described in this document
does not (and cannot) have this property.  Due to the fact that all
processes share a common address space, the text and data segments
will be placed at arbitrary locations relative to each other and will
therefore need a mechanism whereby executable code will always be able
to find its corresponding data.  One of the CPU's registers is
typically dedicated to hold the base address of the data segment. 
This register will be called the "FDPIC register" in this document. 
Such a register is sometimes used in systems with disjoint address
spaces too, but this is for efficiency rather than necessity.

The fact that the locations of the text and data segments are at
non-constant offsets with respect to each other also complicates
function pointer representation.  As noted above, executable code
must be able to find its corresponding data segment.  When making an
indirect function call, it is therefore important that both the
address of the function and the base address of the data segment are
available.  This means that a function pointer needs to represented as
the address of a "function descriptor" which contains the address of
the actual code to execute as well as the corresponding data (FDPIC
register) address.

FDPIC Register
--------------

The FDPIC register is used as a base register for accessing the global
offset table (GOT) and function descriptors.  Since both code and data
are relocatable, executable code may not contain any instruction
sequences which directly encode a pointer's value.  Instead, pointers
to global data are indirectly referenced via the global offset table. 
At load time, pointers contained in the global offset table are
relocated by the dynamic linker to point at the correct locations.

Register R9 is used as the FDPIC register; in this specification it
is caller-save, not callee-save, to avoid problems with PLT entries
needing to save the register.

Upon entry to a function, the caller saved register R9 is the FDPIC
register.  As described above, it contains the GOT address for that
function.  R9 obtains its value in one of three ways:

    1) By being inherited from the calling function in the case
       of a direct call to a function within the same load module.

    2) By being set either in a PLT entry or in inlined PLT code.

    3) By being set from a function descriptor as part of an
       indirect call.

The specifics associated with each of these cases are covered in
greater detail in "Procedure Linkage Table (PLT)" and "Function
Calls", below.

The prologue code of a non-leaf function should save R9 either on
the stack or in one of the callee-saved registers.  After each
function call, R9 must be restored if it is needed later on in the
function.  Direct calls to functions in the same load module and
direct calls which are routed through a PLT entry require that R9 be
restored.  Calls which use inlined PLT code and indirect calls may be
able to avoid using R9; such calls will need to use some other
register in which the GOT address has been saved, however.  A leaf
function makes no calls and need not save R9.

Note that once a function has moved R9 to one of its callee saved
registers, the function is then free to use that register as the FDPIC
register for accessing data.  This is why the sections describing
relocations are careful to specify FDPIC-relative references instead
of R9-relative references.

It's envisioned (though not mandated) that the GOT entries are located
at positive FDPIC-based offsets and that function descriptors are
found at negative offsets to FDPIC.

Function Descriptors
--------------------

A number of programs assume that pointers to functions are as wide as
pointers to data, even though programming languages don't require
this.  However, two words are needed to represent a function pointer
meaningfully:  not only is the function's entry point required, but
also some context information that enables the function to find the
corresponding data segment in the current process.  Such context
information is given in the form of a pointer to the GOT in FDPIC
(which is R9 upon entry to a function).

In order to keep pointers to functions as 32-bit values, while adding
context information to them, we introduce function descriptors, such
that, when the address of a function is taken, the address of its
descriptor is obtained.  As shown below, the descriptor contains
pointers to both the function's entry point and its GOT.  A load
module will also likely contain a number of private function
descriptors which are used in conjunction with a corresponding PLT
entry (or inlined PLT code) for calling a function.

A function descriptor consists of two 4-byte words:

    1) The "entry point" at offset 0 contains the text address of the
       function.  This is the address at which to start executing
       the function.

    2) The "GOT address" at offset 4 contains the value to which the FDPIC
       register must be set when executing the function.

Each direct function call requiring a PLT entry (or which uses inlined
PLT code) requires a function descriptor stored in the data segment.

Each private function descriptor needs to be initialized using a
64-bit relocation which fills in both the function entry point and GOT
address.  The R_ARM_FUNCDESC_VALUE relocation is used for this
purpose.

Function Addresses
------------------

When a function address is required, the address of an "official" (or
canonical) function descriptor is used.  Descriptors corresponding to
static, non-overridable functions are allocated by the link editor
and are initialized at load time via the R_ARM_FUNCDESC_VALUE relocation.
The dynamic linker is responsible for allocating and initializing all
other "official" function descriptors.

As described above, a function's address is actually the address of a
function descriptor, not that of the function's entry point.  As is
the case with other kinds of pointers, executable code obtains the
values of pointer constants via the global offset table.  The
R_ARM_FUNCDESC relocation (see below) is used in global offset table
entries and initialized data to obtain the addresses of function
descriptors used for representing function addresses.

Note: This document borrows many of the concepts and terminology
related to function addresses and their descriptors from the IA-64
System V ABI [1, 2].

Procedure Linkage Table (PLT)
-----------------------------

In order to make direct calls to a function external to a given load
module, the branch instruction's target is a PLT entry.  (Calls to
internal, but overridable functions also need PLT entries.)  The PLT
entry contains instructions for fetching the function's start address
and global pointer value from a function descriptor associated with
the function in question.  The function descriptor will be located at
a fixed offset from the address specified by the FDPIC register.  The
instructions in a PLT entry could look like this:

        plt(foo):       ldr     r12, .L1
                        add     r12, r12, r9
                        ldr     r9, [r12, #4]
                        ldr     pc, [r12]
        L1.             .word   foo@GOTOFFFUNCDESC

Dynamic Linker Reserve Area
---------------------------

The linker reserves three words starting at the location pointed to by
the FDPIC register for use by the dynamic linker.  The first two words
comprise a function descriptor for invoking the resolver used in lazy
dynamic linking.  The third (at R9+8) is used by the dynamic linker
and the debugger to obtain access to information regarding the loaded
module and the amount that each segment has been relocated by.

Lazy Procedure Linkage
----------------------
TODO : MEGA WARNING : lazy linking must use memory barrier to insure order =>
plt must use memory barrier ......

Lazy procedure linkage requires an additional PLT fragment for each
dynamic function that requires a local descriptor in the module.
These entries are not large, but their aggregate will increase the
size of the text segment.  For this reason, the use of lazy dynamic
linking is optional.  (Implementation of lazy dynamic linking in the
dynamic linker is mandatory, however.)

A lazy PLT fragment looks like this:

                        TODO
        lazy_plt(foo):  TODO

The code for "resolverStub" looks like this:

        resolverStub:   TODO

The link editor adds as many ``resolverStub'' fragments as necessary
to ensure that the branch in each lazy PLT fragment is within range.

It is also possible to inline the resolverStub instructions as
follows:

                        TODO
        lazy_plt(foo):  TODO

Lazy PLT fragments have word (32-bit) alignment.

Function descriptors residing in the GOT are initialized so that the
entry point is that of the corresponding lazy PLT entry address.  The
function descriptor's GOT address is initialized to the GOT address
for the load module itself.  These initializations occur as the result
of the dynamic linker performing R_ARM_FUNCDESC_VALUE relocations
(located in the .rel.plt section) at load time.

Thus a function call to an unresolved function will go through the
lazy PLT fragment for that function as a result of picking up the lazy
PLT entry point from the function descriptor.  The lazy PLT fragment
immediately branches to "resolverStub", a special PLT entry which
uses the dynamic linker reserve area (see above) to cause execution to
be transferred to the actual resolver without disturbing either TODO
or R9.  Branches always go to PLT entries, not directly to the
resolver stubs.

Upon entry to the actual (lazy) resolver, the following register
values are important:

    TODO      -- the address of the resolver itself
    TODO      -- the GOT address (FDPIC value) for the resolver's GOT
    TODO(R1)      -- the address of the lazy PLT entry being resolved
    R9      -- the GOT address for the caller's GOT
               or sometimes for the called function's GOT (see below)

The resolver must take care not to modify the argument registers or
the callee-saved registers, or if it does, to restore them to their
original state when it's done.

The resolver uses the word at TODO(R1) - 4 (that is @(-4,TODO(R1)) ) which is
an offset to a R_ARM_FUNCDESC_VALUE relocation.  This offset is
relative to the value (address) associated with the DT_JMPREL tag in
the dynamic section.  (Tags related to DT_JMPREL are DT_PLTRELSZ and
DT_PLTREL.  The value associated with DT_PLTRELSZ provides the size of
this section.  The value associated with DT_PLTREL must be set to
DT_REL indicating that Elf32_Rel structs are used to hold the
relocation information.)  The R_ARM_FUNCDESC_VALUE relocation provides
the offset to the function descriptor to update and the symbol table
index of the function to resolve.

Assuming the resolver completes successfully, it will perform the
following actions prior to transferring control to the entry point of
the resolved function:

    1) Fill in the function descriptor in the caller's GOT so that the
       entry point and GOT address are correct for the next call of
       the resolved function.  As in the Blackfin and SH FDPIC ABI, there is
       a race condition between both words getting written and some
       other thread attempting to read them, and no atomic 64 bit
       load/store instruction that could be used to prevent it.  To
       avoid problems arising from this race, when function
       descriptors are read the entry point must be read before the
       FDPIC pointer, and when the resolver writes them it must write
       the new FDPIC pointer before writing the new entry point.  This
       leaves the possibility of a lazy PLT entry (and so the
       resolver) being called with the FDPIC register pointing to the
       GOT for the load module containing the called function instead
       of the load module containing the call and GOT and PLT entries,
       if the call is made after the resolver was interrupted between
       updating the two words of the function descriptor; the resolver
       must allow for this possibility.  In addition, the resolver may
       need to use locking to ensure that two different threads are
       not updating a function descriptor at the same time to point to
       functions in two different load modules.

    2) Set R9 to the GOT address of the resolvee's GOT.

Function Calls
--------------

Direct function calls are performed as follows:

                "set up arguments as on GNU/Linux with MMU"
                "load function address into a register"
                "call loaded address"
                "restore any needed "caller saves" registers"

The "call loaded address" pseudo-instruction will either transfer
control directly to the function's entry point (for calls to functions
in the same load module) or will transfer control to the function's
PLT entry if one is needed.

Since PLT entries reference R9, a function must ensure that R9
is set correctly prior to making a function call.

Inlined PLT code may be able to make use of the FDPIC value stored in
another register - thus avoiding the need for setting R9.  However,
it would significantly enlarge the code size.

Indirect calls are performed by loading the entry point and GOT
address from the function descriptor into R(TODO) and R9, respectively.
The same atomicity issues apply as when these are loaded from a PLT
entry, so again the entry point address must be loaded first.  Control
is transferred via a jsr(TODO) or jsr/n(TODO) instruction to the function's entry
point, possibly a lazy PLT fragment.  The call site for an indirect
function call might look like this:

                "set up arguments as on GNU/Linux with MMU"
                "load function descriptor address into a register"
                "load entry point and GOT address from function descriptor"
                 into R(TODO) and R9"
                "call loaded entry point"
                "restore any needed "caller saves" registers"

Global Data and the Global Offset Table (GOT)
---------------------------------------------

As noted earlier, position independent code must not contain any
instruction sequences which directly encode a reference to global
data.  If they did so, load time relocations would be necessary to
adjust these addresses.  Also, any reference to a address in a
non-shared segment would force the executable segment in question to
be non-sharable.

The global offset table (GOT) contains words which hold the
addresses of global data.  In order to access these global data,
position independent code must first use an FDPIC-relative load
instruction to fetch the data address from the GOT.
The data structure is then accessed as necessary using the address
obtained from the GOT.  It is envisioned that the various GOT
related structures might look something like this:

                +-----------------------+ <--------------------\
                |          .            |                      |
                           .                                   |
                |          .            |                      |
                +-----------------------+                      |
                |                       |                      |
                +-    Func Descr #2    -+                      |
                |                       |                      |
                +-----------------------+                      |
                |                       |                      |
                +-    Func Descr #1    -+                      |
                |                       |                      |
                +-----------------------+ <---\                |
   FDPIC -----> |                       |     |                |
                +- Resolver Descriptor -+   Dynamic Linker     |
                |                       |   Reserve Area       |
                +-----------------------+     |                |
                |   link_map pointer    |     |                |
                +-----------------------+ <---/             Global
                | Global Data Addr #1   |                   Offset
                +-----------------------+                   Table
                | Global Data Addr #2   |                   (GOT)
                +-----------------------+                      |
                | Global Data Addr #3   |                      |
                +-----------------------+                      |
                |          .            |                      |
                           .                                   |
                |          .            |                      |
                +-----------------------+ <--------------------/

The link-editor is responsible for determining the precise layout
of the GOT.  The only hard requirements are the following:

    (a) FDPIC must point at the first word of the dynamic linker
        reserve area.
    (b) The global offset table must reside in a non-shared segment.

In the picture above, function descriptors are placed at negative
offsets relative to R9 and the GOT data address entries are placed at
positive offsets relative to R9.  The link editor is free to place
either the function descriptors at positive offsets (subject to
alignment constraints) or the data address entries at negative
offsets.  Also, note that there is no requirement that the function
descriptors or data address entries have any particular grouping.

GOT initialization is performed at load time by the dynamic linker.
In order to accomplish these initializations, the dynamic linker uses
relocations that have been placed in the object file by the link
editor.  These relocations (as already defined for non-FDPIC) may
cause addresses of other global data in other load modules to be
resolved or the relocation may refer to data within the same load
module.  (For function descriptors, the R_ARM_FUNCDESC_VALUE relocation
is used.  This relocation is described in greater detail below.)

Each load module has a symbol _GLOBAL_OFFSET_TABLE_ which resolves to
the GOT address for that load module.  The DT_PLTGOT dynamic section
entry in each load module contains the GOT address also.  The GOT
address points to the dynamic linker reserve area.

TODO ==>
HERE describe access to global data according to sections
HERE a travailler rapidement car important

The simplest way to load the address of a data object, on all SH
variants, is:

        mov.l .L1, r0
        mov.l @(r0,r12), rN

    L1: .long foo@GOT
TODO <==

Variables initialized with pointers (to data or code) must not be
assigned to read-only segments; the dynamic linker will need to set up
the pointers at module load time.

Preexisting Relocation Types
----------------------------

The existing relocations implemented by the GNU linker may be used
with FDPIC code with their existing semantics, although some may not
be useful in this context.  When an existing relocation is applied to
a function symbol, it is taken to refer to the function entry point
(possibly a PLT entry), not to a function descriptor.

New Relocations
---------------

The following are new relocation types for supporting position independent
code with function descriptors.

    Name                    Value  Meaning
    ----                    -----  -------
    R_ARM_GOTFUNCDESC       TODO   Used for the FDPIC-relative offset
                                    to a GOT entry containing a
                                    pointer to a function descriptor
                                    for a symbol.
    R_ARM_FUNCDESC          TODO   Used for a pointer to an "official"
                                    function descriptor, in both GOT
                                    entries and user-initialized data.
    R_ARM_FUNCDESC_VALUE    TODO   Used to fill in function entry point
                                    and GOT address in private function
                                    descriptors

The dynamic loader needs to adjust or "fix up" portions of the data
segment due to it being dynamically located.  The various dynamic
relocation entries tell the dynamic loader how to do this.  The text
segment is dynamically located too, but it is read-only and must not
have any relocation entries associated with it.

New dynamic relocations have the following types: R_ARM_FUNCDESC and
R_ARM_FUNCDESC_VALUE.  The precise interpretation given to these
relocation types by the dynamic linker is described in the following
paragraphs.

  R_ARM_FUNCDESC
  --------------
    The R_ARM_FUNCDESC relocation is used to obtain the address of an
    "official" function descriptor from the dynamic linker.  The
    "r_offset" field contains the location (offset) of the word
    which must receive this address.  The "r_info" field contains an
    encoding of the symbol table index corresponding to the function
    to resolve.  The dynamic linker resolves the function and
    determines the address of the corresponding official descriptor,
    allocating and initializing it as necessary.  (It is the dynamic
    linker's responsibility to allocate and initialize all official
    descriptors.)  The address of the official descriptor is written to
    the location specified by "r_offset".

    Note: This relocation is always expected to reference symbols for
    which the dynamic linker is expected to create an "official
    descriptor".  References to descriptors (for static or hidden
    functions) which are allocated and initialized by the link editor
    are handled via pre-existing relocations.

  R_ARM_FUNCDESC_VALUE
  --------------------
    The R_ARM_FUNCDESC_VALUE relocation is used to initialize
    both words of a function descriptor.  The "r_offset" member (in
    an Elf32_Rel struct) specifies the location of the descriptor to
    initialize.  The "r_info" member encodes both the number
    associated with the R_ARM_FUNCDESC_VALUE type and a symbol table
    index.

    Support for lazy binding is accomplished by R_ARM_FUNCDESC_VALUE
    relocations residing in the .rel.plt section.  The symbol index
    encoded in "r_info" corresponds to the symbol to resolve.  In
    the descriptor itself, the link editor sets the low word to the
    address of the lazy PLT entry which, when executed, will ultimately
    resolve the symbol.  The high word is set to the index of the
    segment containing the lazy PLT code.  Relocations in .rel.plt are
    potentially processed twice, once at load time to fix up the
    offset so that the function descriptor really points at the lazy
    PLT entry, and possibly later on, as a result of the code in the
    lazy PLT entry being run, forcing actual binding to be done. 
    Note:  The environment variable "LD_BIND_NOW" may be set to a
    non-null value to force binding to occur at load time.  When
    "LD_BIND_NOW" is used for this purpose, the descriptor's
    contents are ignored, and the relocations are only processed
    once.

    R_ARM_FUNCDESC_VALUE relocations found outside of .rel.plt are
    used either for non-lazy binding support (forced at compile/link
    time) or for static function descriptor initializations.  These
    cases will be considered separately.
    
    Relocations used for resolving external functions (in a non-lazy
    manner) have the symbol index encoded in "r_info" set to
    correspond to symbol to resolve.  The descriptor contents are
    irrelevant and are ignored.  The function corresponding to the
    symbol index is resolved and the entry point and GOT address
    for that function are written to the descriptor.

    The R_ARM_FUNCDESC_VALUE relocation is also used to initialize
    function descriptors used as addresses for static, non-overridable
    functions.  When used for this purpose, the "r_info" member encodes
    the symbol table index for the section in which the function is
    found.  The low word of the descriptor contains the offset to the
    function and the high word contains the segment index.

    The segment index can be used to speed up the computation of the
    address of the symbol, if the dynamic linker maintains internally
    an array that maps a segment number to the offset by which it was
    relocated.  Such a map is not required, though, and the dynamic
    linker is free to ignore segment index information.

Assembler operators
-------------------

Below is a list of additional operators for writing assembly code.

    Name                Corresponding relocations
    ----                -------------------------

    @GOTFUNCDESC        R_ARM_GOTFUNCDESC
    TODO

ELF Header
----------

The ARM processor specific flag for the "e_flags" field in the ELF
header which indicates the use of this ABI is EF_ARM_FDPIC.  The value
for this flag is 0x00008000(TODO).  A flag EF_ARM_PIC, value 0x00000100(TODO), is
also defined.

When both EF_ARM_FDPIC and EF_ARM_PIC are set, it means each segment of
the binary can be loaded at an arbitrary address, which means sharing
of text segments is possible.  If EF_ARM_FDPIC is set but EF_ARM_PIC is
clear, all segments must be relocated by the same amount.  The linker
should warn and clear EF_ARM_PIC when linking FDPIC binaries if it
finds any inter-segment relocation, and set it otherwise.  Examples of
inter-segment relocations are a PC-relative relocation referencing a
symbol that is not in the text segment, or a GOTOFF relocation
referencing a symbol that is not in the data segment.

