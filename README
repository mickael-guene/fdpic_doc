Introduction
------------

This document describes extensions (and some minor changes) to the
existing ARM ELF ABI (as used on GNU/Linux) required to support the
implementation of shared libraries on a system whose OS (and hardware)
require that processes share a common address space.  This document
will also attempt to explore the motivations behind and the
implications of these extensions.

One of the primary goals in using shared libraries is to reduce the
memory requirements of the overall system.  Thus, if two processes use
the same library, the hope is that at least some of the memory pages
will be shared between the two processes resulting in an overall
savings.  To realize these savings, tools used to build a program and
library must identify which sections may be shared and which must not
be shared.  The shared sections, when grouped together, are commonly
referred to as the "text segment" whereas the non-shared (grouped)
sections are commonly referred to as the "data segment".  The text
segment is read-only and is usually comprised of executable code and
read-only data.  The data segment must be writable and it is this fact
which makes it non-sharable.

Systems which utilize disjoint address spaces for its processes are
free to group the text and data segments in such a way that they
may always be loaded with fixed relative positions of the text
and data segments.  I.e, for a given load object, the offset from
the start of the text segment to the start of the data segment is
constant.  This property greatly simplifies the design of the
shared library machinery.

The design of the shared library mechanism described in this document
does not (and cannot) have this property.  Due to the fact that all
processes share a common address space, the text and data segments
will be placed at arbitrary locations relative to each other and will
therefore need a mechanism whereby executable code will always be able
to find its corresponding data.  One of the CPU's registers is
typically dedicated to hold the base address of the data segment. 
This register will be called the "FDPIC register" in this document. 
Such a register is sometimes used in systems with disjoint address
spaces too, but this is for efficiency rather than necessity.

The fact that the locations of the text and data segments are at
non-constant offsets with respect to each other also complicates
function pointer representation.  As noted above, executable code
must be able to find its corresponding data segment.  When making an
indirect function call, it is therefore important that both the
address of the function and the base address of the data segment are
available.  This means that a function pointer needs to represented as
the address of a "function descriptor" which contains the address of
the actual code to execute as well as the corresponding data (FDPIC
register) address.

FDPIC Register
--------------

The FDPIC register is used as a base register for accessing the global
offset table (GOT) and function descriptors.  Since both code and data
are relocatable, executable code may not contain any instruction
sequences which directly encode a pointer's value.  Instead, pointers
to global data are indirectly referenced via the global offset table. 
At load time, pointers contained in the global offset table are
relocated by the dynamic linker to point at the correct locations.

Register R9 is used as the FDPIC register; in this specification it
is caller-save, not callee-save, to avoid problems with PLT entries
needing to save the register.

Upon entry to a function, the caller saved register R9 is the FDPIC
register.  As described above, it contains the GOT address for that
function.  R9 obtains its value in one of three ways:

    1) By being inherited from the calling function in the case
       of a direct call to a function within the same load module.

    2) By being set either in a PLT entry or in inlined PLT code.

    3) By being set from a function descriptor as part of an
       indirect call.

The specifics associated with each of these cases are covered in
greater detail in "Procedure Linkage Table (PLT)" and "Function
Calls", below.

The prologue code of a non-leaf function should save R9 either on
the stack or in one of the callee-saved registers.  After each
function call, R9 must be restored if it is needed later on in the
function.  Direct calls to functions in the same load module and
direct calls which are routed through a PLT entry require that R9 be
restored.  Calls which use inlined PLT code and indirect calls may be
able to avoid using R9; such calls will need to use some other
register in which the GOT address has been saved, however.  A leaf
function makes no calls and need not save R9.

Note that once a function has moved R9 to one of its callee saved
registers, the function is then free to use that register as the FDPIC
register for accessing data.  This is why the sections describing
relocations are careful to specify FDPIC-relative references instead
of R9-relative references.

It's envisioned (though not mandated) that the GOT entries are located
at positive FDPIC-based offsets and that function descriptors are
found at negative offsets to FDPIC.

Function Descriptors
--------------------

A number of programs assume that pointers to functions are as wide as
pointers to data, even though programming languages don't require
this.  However, two words are needed to represent a function pointer
meaningfully:  not only is the function's entry point required, but
also some context information that enables the function to find the
corresponding data segment in the current process.  Such context
information is given in the form of a pointer to the GOT in FDPIC
(which is R9 upon entry to a function).

In order to keep pointers to functions as 32-bit values, while adding
context information to them, we introduce function descriptors, such
that, when the address of a function is taken, the address of its
descriptor is obtained.  As shown below, the descriptor contains
pointers to both the function's entry point and its GOT.  A load
module will also likely contain a number of private function
descriptors which are used in conjunction with a corresponding PLT
entry (or inlined PLT code) for calling a function.

A function descriptor consists of two 4-byte words:

    1) The "entry point" at offset 0 contains the text address of the
       function.  This is the address at which to start executing
       the function.

    2) The "GOT address" at offset 4 contains the value to which the FDPIC
       register must be set when executing the function.

Each direct function call requiring a PLT entry (or which uses inlined
PLT code) requires a function descriptor stored in the data segment.

Each private function descriptor needs to be initialized using a
64-bit relocation which fills in both the function entry point and GOT
address.  The R_ARM_FUNCDESC_VALUE relocation is used for this
purpose.

Function Addresses
------------------

When a function address is required, the address of an "official" (or
canonical) function descriptor is used.  Descriptors corresponding to
static, non-overridable functions are allocated by the link editor
and are initialized at load time via the R_ARM_FUNCDESC_VALUE relocation.
The dynamic linker is responsible for allocating and initializing all
other "official" function descriptors.

As described above, a function's address is actually the address of a
function descriptor, not that of the function's entry point.  As is
the case with other kinds of pointers, executable code obtains the
values of pointer constants via the global offset table.  The
R_ARM_FUNCDESC relocation (see below) is used in global offset table
entries and initialized data to obtain the addresses of function
descriptors used for representing function addresses.

Note: This document borrows many of the concepts and terminology
related to function addresses and their descriptors from the IA-64
System V ABI [1, 2].

